# Distributed Ledger Technologies / Blockchain : Software Design Patterns


## Principles

### Immutability

Blockchains are immutable.

### Atomicity

Entire operation runs or none of it does.

### Asynchrony

Blockchains are designed to run on any number of computers/nodes.

### Consensus

Uses algorithms to reach Distributed Consensus.

### Reliability

Algorithms assume that network is not reliable.

### Synchrony

No two operations can interfere with each other.

### Provenance

All method calls can be inspected to determine caller address.


## Data Patterns

### Merkel Tree

#### Structure
```uml
[<package>Merkel Tree |
	[Node |
		signature
		children
		|
		hash(string)
		toString()
	]children o-[Node]
	[Node]o-[DataBlock]
]

```

#### Instance

```uml
[<package>Merkel Tree |
	[<instance>datablock 1]->[<instance>node 1.1.1]
	[<instance>datablock 2]->[<instance>node 1.1.2]
	[<instance>datablock 3]->[<instance>node 1.2.1]
	[<instance>datablock 4]->[<instance>node 1.2.2]
	[<instance>node 1.1.1 | signature]->[<instance>node 1.1| signature]
	[<instance>node 1.1.2| signature]->[node 1.1]
	[<instance>node 1.2.1| signature]->[<instance>node 1.2| signature]
	[<instance>node 1.2.2| signature]->[node 1.2]
	[node 1.2]->[<instance>node 1| signature]
	[node 1.1]->[node 1]

]

```

Where node[1.1].signature = hash(concatenate(node[1.1.1].toString(),node[1.1.2].toString())))
etc.

#### Applications
+ Git
+ Modern File Systems

### Merkel Trie / Blockchain

#### Structure
```uml
[<package>Merkel Trie |
	[Node |
		signature
		block
		parent
		|
		hash(string)
		toString()
	]parent o-[Node]
	[Node]blocko-[DataBlock]
]

```

#### Instance

```uml

[<package>Merkel Trie |
	[...]->[<instance>root n | signature]
	[<instance>block n | signature]->[root n]
	[root n]->[<instance>root n+1 | signature]
	[<instance>block n+1 | signature]->[root n+1]
	[root n+1]->[<instance>root n+2 | signature]
	[<instance>block n+2 | signature]->[root n+2]
	[root n+2]->[....]

]

```

Where root[i+1].signature = hash(concatenate(root[i].toString(),block[i].toString()))
etc.

#### Applications
+ Blockchain

### Block

```uml
[<package>Block |

[Block |
	header: BlockHeader
	transactions: CountableList(Transaction)
	uncles: CountableList(BlockHeader)
	db = None
    	bloom_filter = None
		transaction_class = FrontierTransaction
		|
		__init__(header, db, transactions=None, uncles=None)
		validate_gas_limit()
		validate()
		validate_uncle(uncle)
		number()
		hash()
		get_parent_header()
		get_transaction_class(cls)
		get_cumulative_gas_used()
		receipts()
		from_header(cls, header, db)
		add_transaction(transaction, computation)
		add_uncle(uncle)
		mine(**kwargs)
	

]

[Block]transactions o-[Transaction]
[Block]header o-[BlockHeader]

[rlp.Serializable]<:-[Block]
[rlp.Serializable]<:-[BlockHeader]
        [BlockHeader |
            parent_hash: hash32
			uncles_hash: hash32
			coinbase: address
			state_root: trie_root
			transaction_root: trie_root
			receipt_root: trie_root
			bloom: int256
			difficulty: big_endian_int
			block_number: big_endian_int
			gas_limit: big_endian_int
			gas_used: big_endian_int
			timestamp: big_endian_int
			extra_data: binary
			mix_hash: binary
			nonce: Binary(8, allow_empty=True)
            |
            __init__(difficulty, block_number, gas_limit, 
				timestamp=None, coinbase=ZERO_ADDRESS, parent_hash=ZERO_HASH32, 
				uncles_hash=EMPTY_UNCLE_HASH, state_root=BLANK_ROOT_HASH, transaction_root=BLANK_ROOT_HASH, 
				receipt_root=BLANK_ROOT_HASH, bloom=0, gas_used=0, 
				extra_data=b'', mix_hash=ZERO_HASH32, nonce=GENESIS_NONCE)
            hash()
            mining_hash()
            hex_hash()
            from_parent(cls, parent, gas_limit, difficulty, coinbase=ZERO_ADDRESS, 
			timestamp=None, nonce=None, extra_data=None)
        ]
]
		
```


#### Applications
+ Blockchain

### Transaction

```uml
[<package>Transaction |
[Block |transactions|]o-transactions[Transaction |
	nonce: g_endian_int
	gas_price: big_endian_int
	gas: big_endian_int
	to: address
	value: big_endian_int
	data: binary
	v: big_endian_int
	r: big_endian_int
	s: big_endian_int
		|
		validate()
		check_signature_validity()
		get_sender()
		get_intrensic_gas()
		as_unsigned_transaction()
		create_unsigned_transaction(cls, nonce, gas_price, gas, to, value, data)
	]

]

```

#### Applications
+ Blockchain

## Behavior Patterns

### Singleton

```uml

[<package> Singleton |
	[<state>Network |
		blocks
		
	]-->[Singleton/Virtual Machine |
		interpreter
		state
	]

]


```

One single instance of:
+ data
+ behavior
+ events

#### Applications
+ Blockchain

### (Smart) Contract

```uml

[<package> Contract |
	[<state>Network |
		blocks
	]o-blocks[Block]
	[Block]o-contracts[Contract |
	
	owner: Address
	|
	Contract() // constructor
	]
	

]


```

#### Mortal Contract

By default the contracts are immortal. They could trap funds if they cannot be stopped from operation.


```uml

[<package> Mortal Contract |
	
	[<abstract>Contract]<:-[<abstract>Mortal |
		owner: Address
		|
		Mortal()
		Kill()
	]
	[Mortal]<:-[ConcreteMortal||]
]


```

### Contract Interoperativity

```uml

[<package> Contract Interoperativity|
	[<abstract>ERC20Interface |
		|
		totalSupply() constant returns (uint totalSupply)
		balanceOf(address _owner) constant returns (uint balance)
		transfer(address _to, uint _value) returns (bool success)
		transferFrom(address _from, address _to, uint _value) returns (bool success)
		approve(address _spender, uint _value) returns (bool success)
		allowance(address _owner, address _spender) constant returns (uint remaining)
		|
 		Transfer(address indexed _from, address indexed _to, uint _value)
		Approval(address indexed _owner, address indexed _spender, uint _value)
		
	]
	[ERC20Interface]<:-[Contract1 ||]
	[ERC20Interface]<:-[Contract2 ||]
	
	[ERC20Interface]<:-[<abstract>HumanStandardToken |
		+name: string
		+decimals: uint8
		+symbol: string
		+version = 'H0.1'
	]
	
	[HumanStandardToken]<:-[Contract3 ||]
	

]
```
Contract1, 2, 3 are interoperable

### Oracle

Stores trusted information onto the blockchain.

```uml
[<package>Oracle |
	
	
	[<abstract>Contract||]<:-[OracleConnector|
		notary
		data
		|
		query(URL)
		saveData(signed_data)
	]
	[OracleConnector]-->[<state>TLSNotary |
		signature
		timestamp
		
		| verify()
		query(URL)
		signResult()
		]
	
	


]
```


### Observer/Judge

```uml
[<package>Observer |
	
	
	[<abstract>Contract||]<:-[ObservedContract|
		deadline: uint
		value: uint
		role1: Address
		role2: Address
		observer: Address
		status: uint
		|
		observe()
		|
		event: statusChange
	]
	[ObservedContract]-->[<abstract>Observer |
		
		|
		notify(Address)
		]
	

]
```

A more detailed UML and implementation: [ontrack-dapp](https://github.com/loredanacirstea/ontrack-dapp)

## Composite Patterns

### Twin Contracts

Twin smart contracts usually are born and die together. Also the transcations they initiate are born in synchronicity and atomically in mirror on their respective newtorks.

```uml
[<package>Twin Contracts |
	
	[<abstract>TwinInterface1|twins: CountableList(Contract)|]
	[<state>NetworkA]-->[ContractTwin1A|twins]
	[<state>NetworkB]-->[ContractTwin1B|twins]
	[TwinInterface1]<:-[ContractTwin1A]
	[TwinInterface1]<:-[ContractTwin1B]
	[ContractTwin1B]--knows[ContractTwin1A]


]


```

### Contract Factory

```uml
[<package>Contract Factory |
	
	[<state>ContractFactory |
		param1
		param2
		contracts: CountableList(Contract)
		
		| 
		setParam(data)
		createContract()
		]o-contracts[ConcreteContract1||]
		

]


```

### Contract of Contracts

A contract that implements contract factory for any number of contracts.


## Terminology (from Ethereum)

### External Actor
A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.
### Address
A 160-bit code used for identifying Accounts.
### Account
Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.
### Transaction
A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.
### Autonomous Object
A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated only as the Storage State of that account.
### Storage State
The information particular to a given Account that is maintained between the times that the Account’s associated EVM Code runs.
### Message
Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.
### Message Call
The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.
### Gas
The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.
### Contract
Informal term used to mean both a piece of EVM Code that may be associated with an Account or an Autonomous Object.
### Object
Synonym for Autonomous Object.
### ETHEREUM
A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER EIP-150 REVISION 16
### App
An end-user-visible application hosted in the Ethereum Browser.
### Ethereum Browser:
(aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum protocol.
### Ethereum Virtual Machine
(aka EVM) The virtual machine that forms the key part of the execution model for an Account’s associated EVM Code.
### Ethereum Runtime Environment
(aka ERE) The environment which is provided to an Autonomous Object executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for certain I/O instructions including CALL &amp; CREATE.
### EVM Code
The bytecode that the EVM can natively execute. Used to formally specify the meaning and ramifications of a message to an Account.
### EVM Assembly
The human-readable form of EVM-code.
### LLL
The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general low-level language toolkit for trans-compiling to.



```uml
http://orobo.go.ro:4500/info.txt
```